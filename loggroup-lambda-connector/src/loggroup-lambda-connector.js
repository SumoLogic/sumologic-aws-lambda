const { CloudWatchLogsClient, PutSubscriptionFilterCommand, DescribeLogGroupsCommand } = require("@aws-sdk/client-cloudwatch-logs");
const { LambdaClient, InvokeCommand } = require("@aws-sdk/client-lambda");

const cwl = new CloudWatchLogsClient();
const lambda = new LambdaClient({ apiVersion: '2015-03-31' }); // Update to the appropriate Lambda API version you require
const maxRetryCounter = 3;
const timeoutThreshold = 12000;

async function createSubscriptionFilter(lambdaLogGroupName, destinationArn, roleArn, additionalArgs) {
    var params={};
    if (destinationArn.startsWith("arn:aws:lambda")) {
        params = {
            destinationArn: destinationArn,
            filterName: 'SumoLGLBDFilter',
            filterPattern: '',
            logGroupName: lambdaLogGroupName
        };
    } else {
        params = {
            destinationArn: destinationArn,
            filterName: 'SumoLGLBDFilter',
            filterPattern: '',
            logGroupName: lambdaLogGroupName,
            roleArn: roleArn
        };
    }

    // handle the case where the subscription filter exists / case where the log group is generated by the target lambda
    try {
        const cmd = new PutSubscriptionFilterCommand(params);
        await cwl.send(cmd);
        additionalArgs.subscribeCount += 1
        console.log("Successfully subscribed logGroup: ", lambdaLogGroupName);
    } catch (err) {
        console.log("Error in subscribing", lambdaLogGroupName, err);
        throw err;
    }
}

function filterLogGroups(event, logGroupRegex) {
    logGroupRegex = new RegExp(logGroupRegex, "i");
    let logGroupName = event.detail.requestParameters.logGroupName;
    if (logGroupName.match(logGroupRegex) && event.detail.eventName === "CreateLogGroup") {
        return true;
    }
    let lg_tags = event.detail.requestParameters.tags;
    if (process.env.LOG_GROUP_TAGS && lg_tags) {
        console.log("tags in loggroup: ", lg_tags);
        var tags_array = process.env.LOG_GROUP_TAGS.split(",");
        let tag, key, value;
        for (let i = 0; i < tags_array.length; i++) {
            tag = tags_array[i].split("=");
            key = tag[0].trim();
            value = tag[1].trim();
            if (lg_tags[key] && lg_tags[key] == value) {
                return true;
            }
        }
    }
    return false;
}

async function subscribeExistingLogGroups(logGroups, retryCounter, additionalArgs) {
    var logGroupRegex = new RegExp(process.env.LOG_GROUP_PATTERN, "i");
    var destinationArn = process.env.DESTINATION_ARN;
    var roleArn = process.env.ROLE_ARN;
    const failedLogGroupNames = [];
    await logGroups.reduce(async (previousPromise, nextLogGroup) => {
        await previousPromise;
        const { logGroupName } = nextLogGroup;
        if (!logGroupName.match(logGroupRegex)) {
            console.log("Unmatched logGroup: ", logGroupName);
            return Promise.resolve();
        } else {
            return createSubscriptionFilter(logGroupName, destinationArn, roleArn, additionalArgs).catch(function (err) {
                if (err && err.message === "Rate exceeded") {
                    failedLogGroupNames.push({ logGroupName: logGroupName });
                }
            });
        }
    }, Promise.resolve());

    if (retryCounter <= maxRetryCounter && failedLogGroupNames.length > 0) {
        console.log("Retrying Subscription for Failed Log Groups due to throttling with counter number as " + retryCounter);
        await subscribeExistingLogGroups(failedLogGroupNames, retryCounter + 1, additionalArgs);
    }
}

async function processExistingLogGroups(context, token, additionalArgs, errorHandler) {
    var params = { limit: 50 };
    if (token) {
      params = {
        limit: 50,
        nextToken: token
      };
    }

    try {
      console.log("Previous record count " + additionalArgs.recordCount);
      const data = await cwl.send(new DescribeLogGroupsCommand(params));
      additionalArgs.recordCount += data.logGroups.length;
      console.log("Updated record count " + additionalArgs.recordCount);
      await subscribeExistingLogGroups(data.logGroups, 1, additionalArgs);
      console.log("Updated subscribeCount " + additionalArgs.subscribeCount);
      if (data.nextToken) {
        const remainingTime = context.getRemainingTimeInMillis(); // 60000
        const diffTime = remainingTime - timeoutThreshold  // 14552-12000=2792
        if (diffTime < timeoutThreshold) {
            additionalArgs.invokeCount += 1
            console.log("Lambda invoke complete with token "+ data.nextToken);
            console.log("InvokeCount " + additionalArgs.invokeCount);
            await invoke_lambda(context, data.nextToken, additionalArgs, errorHandler);
            return
        }
        console.log("Remaining time " + remainingTime);
        console.log("Log Groups remaining...Calling the lambda again with token " + data.nextToken);
        await processExistingLogGroups(context, data.nextToken, additionalArgs, errorHandler)
      } else {
        console.log("Total " + additionalArgs.subscribeCount + " out of " +  additionalArgs.recordCount
        + " Log Groups are subscribed to Destination Type "
        + process.env.DESTINATION_ARN);
        console.log("Last invokeCount " + additionalArgs.invokeCount);
        errorHandler(null, "Success");
      }
    } catch (err) {
      errorHandler(err, "Error in fetching logGroups");
    }
  }

async function invoke_lambda(context, token, additionalArgs, errorHandler) {
  var payload = { "existingLogs": "true", "token": token, "additionalArgs": additionalArgs};
  try {
    await lambda.send(new InvokeCommand({
      InvocationType: 'Event',
      FunctionName: context.functionName,
      Payload: JSON.stringify(payload)
    }));
  } catch (err) {
      errorHandler(err, "Error invoking Lambda");
  }
}

async function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function processEvents(env, event, additionalArgs, errorHandler, retryCounter=0) {
  var logGroupName = event.detail.requestParameters.logGroupName;
  if (filterLogGroups(event, env.LOG_GROUP_PATTERN)) {
    console.log("Subscribing: ", logGroupName, env.DESTINATION_ARN);
    try {
        await createSubscriptionFilter(logGroupName, env.DESTINATION_ARN, env.ROLE_ARN, additionalArgs);
    } catch (err) {
      errorHandler(err, "Error in Subscribing.");
      if (err && err.message === "Rate exceeded" && retryCounter <= maxRetryCounter) {
        retryCounter += 1
        const delayTime = Math.pow(2, retryCounter) * 1000; // Exponential backoff
        console.log(`ThrottlingException encountered. Retrying in ${delayTime}ms...Attempt ${retryCounter}/${maxRetryCounter}`);
        await delay(delayTime);
        await processEvents(env, event, additionalArgs, errorHandler, retryCounter);
      }
    };
  } else {
      console.log("Unmatched: ", logGroupName, env.DESTINATION_ARN);
  }
}

exports.handler = async function (event, context, callback) {
  let additionalArgs = {
    recordCount: 0,
    subscribeCount: 0,
    invokeCount: 0
  };
  if (event.additionalArgs) {
     additionalArgs = event.additionalArgs
  }
  console.log("Invoking Log Group connector function");
  function errorHandler(err, msg) {
    if (err) {
      console.log(err, msg);
        callback(err);
      } else {
        callback(null, "Success");
      }
    }
    if (event.existingLogs == "true") {
      await processExistingLogGroups(context, event.token, additionalArgs, errorHandler);
    } else {
      await processEvents(process.env, event, additionalArgs, errorHandler);
    }
};