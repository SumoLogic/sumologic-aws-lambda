const { CloudWatchLogsClient, PutSubscriptionFilterCommand, DescribeLogGroupsCommand, ListTagsLogGroupCommand } = require("@aws-sdk/client-cloudwatch-logs");
const { LambdaClient, InvokeCommand } = require("@aws-sdk/client-lambda");

const cwl = new CloudWatchLogsClient();
const lambda = new LambdaClient({ apiVersion: '2015-03-31' }); // Update to the appropriate Lambda API version you require
const maxRetryCounter = 3;
const timeoutThreshold = 12000;


function validateRegex(pattern) {
    try {
        // Attempt to create a RegExp object with the provided pattern
        return new RegExp(pattern, "i");
    } catch (e) {
        // Throw an error with a descriptive message if the pattern is invalid
        throw new Error(`Invalid regular expression pattern: ${pattern}. Error: ${e.message}`);
    }
}

async function getTagsByLogGroupName(logGroupName, retryCounter=0) {
    var tags = {};
    const input = {
      logGroupName: logGroupName, // required
    };
    try {
        // ListTagsLogGroupRequest
        let response = await cwl.send(new ListTagsLogGroupCommand(input));
        tags = response.tags
    } catch (err) {
          if (err && err.message === "Rate exceeded" && retryCounter <= maxRetryCounter) {
            retryCounter += 1
            const delayTime = Math.pow(2, retryCounter) * 2000; // Exponential backoff
            console.log(`ThrottlingException encountered for ${logGroupName}. Retrying in ${delayTime}ms...Attempt ${retryCounter}/${maxRetryCounter}`);
            await delay(delayTime);
            await getTagsByLogGroupName(logGroupName, retryCounter);
          } else {
            console.error(`Failed to get tags for ${logGroupName} due to ${err}`)
          }
    }
    return tags
}

function IsTagMatchToLogGroup(tagMatcherForLogGroup, logGroupTags) {
    if (tagMatcherForLogGroup && logGroupTags) {
        let tagMatcherList = tagMatcherForLogGroup.split(",");
        console.log("logGroupTags: ", logGroupTags);
        let tag, key, value;
        for (let i = 0; i < tagMatcherList.length; i++) {
            tag = tagMatcherList[i].split("=");
            key = tag[0].trim();
            value = tag[1].trim();
            if (logGroupTags[key] && logGroupTags[key] == value) {
                return true;
            }
        }
    }
    return false;
}

async function filterExistingLogGroups(logGroupName, logGroupRegex) {
    if (logGroupName.match(logGroupRegex)) {
        return true;
    }
    var logGroupTags = await getTagsByLogGroupName(logGroupName)
    var tagMatcherForLogGroup = process.env.LOG_GROUP_TAGS
    console.log("Filtering log group:", logGroupName, "with tags:", logGroupTags);
    return IsTagMatchToLogGroup(tagMatcherForLogGroup, logGroupTags)
}

function filterNewLogGroups(event, logGroupRegex) {
    var logGroupName = event.detail.requestParameters.logGroupName;
    if (logGroupName.match(logGroupRegex) && event.detail.eventName === "CreateLogGroup") {
        return true;
    }
    var logGroupTags = event.detail.requestParameters.tags;
    var tagMatcherForLogGroup = process.env.LOG_GROUP_TAGS
    return IsTagMatchToLogGroup(tagMatcherForLogGroup, logGroupTags)
}

async function createSubscriptionFilter(lambdaLogGroupName, destinationArn, roleArn, additionalArgs) {
    var params={};
    if (destinationArn.startsWith("arn:aws:lambda")) {
        params = {
            destinationArn: destinationArn,
            filterName: 'SumoLGLBDFilter',
            filterPattern: '',
            logGroupName: lambdaLogGroupName
        };
    } else {
        params = {
            destinationArn: destinationArn,
            filterName: 'SumoLGLBDFilter',
            filterPattern: '',
            logGroupName: lambdaLogGroupName,
            roleArn: roleArn
        };
    }

    // handle the case where the subscription filter exists / case where the log group is generated by the target lambda
    try {
        const cmd = new PutSubscriptionFilterCommand(params);
        await cwl.send(cmd);
        additionalArgs.subscribeCount += 1
        console.log("Successfully subscribed logGroup: ", lambdaLogGroupName);
    } catch (err) {
        console.log("Error in subscribing", lambdaLogGroupName, err);
        throw err;
    }
}

async function subscribeExistingLogGroups(logGroups, retryCounter, additionalArgs) {
    var logGroupRegex = validateRegex(process.env.LOG_GROUP_PATTERN);
    console.log("logGroupRegexPattern: ", logGroupRegex);
    var destinationArn = process.env.DESTINATION_ARN;
    var roleArn = process.env.ROLE_ARN;
    const failedLogGroupNames = [];
    await logGroups.reduce(async (previousPromise, nextLogGroup) => {
        await previousPromise;
        const { logGroupName } = nextLogGroup;
        let filterStatus = await filterExistingLogGroups(logGroupName, logGroupRegex);
        if (filterStatus) {
            return createSubscriptionFilter(logGroupName, destinationArn, roleArn, additionalArgs).catch(function (err) {
                if (err && err.message === "Rate exceeded") {
                    failedLogGroupNames.push({ logGroupName: logGroupName });
                }
            });
        } else {
            console.log("Unmatched logGroup: ", logGroupName);
            return Promise.resolve();
        }
    }, Promise.resolve());

    if (retryCounter <= maxRetryCounter && failedLogGroupNames.length > 0) {
        console.log("Retrying Subscription for Failed Log Groups due to throttling with counter number as " + retryCounter);
        await subscribeExistingLogGroups(failedLogGroupNames, retryCounter + 1, additionalArgs);
    }
}

async function processExistingLogGroups(context, token, additionalArgs, errorHandler) {
    var params = { limit: 50 };
    if (token) {
      params = {
        limit: 50,
        nextToken: token
      };
    }

    try {
      console.log("Previous record count " + additionalArgs.recordCount);
      const data = await cwl.send(new DescribeLogGroupsCommand(params));
      additionalArgs.recordCount += data.logGroups.length;
      console.log("Updated record count " + additionalArgs.recordCount);
      await subscribeExistingLogGroups(data.logGroups, 1, additionalArgs);
      console.log("Updated subscribeCount " + additionalArgs.subscribeCount);
      if (data.nextToken) {
        const remainingTime = context.getRemainingTimeInMillis(); // 60000
        const diffTime = remainingTime - timeoutThreshold  // 14552-12000=2792
        if (diffTime < timeoutThreshold) {
            additionalArgs.invokeCount += 1
            console.log("Lambda invoke complete with token "+ data.nextToken);
            console.log("InvokeCount " + additionalArgs.invokeCount);
            await invoke_lambda(context, data.nextToken, additionalArgs, errorHandler);
            return
        }
        console.log("Remaining time " + remainingTime);
        console.log("Log Groups remaining...Calling the lambda again with token " + data.nextToken);
        await processExistingLogGroups(context, data.nextToken, additionalArgs, errorHandler)
      } else {
        console.log("Total " + additionalArgs.subscribeCount + " out of " +  additionalArgs.recordCount
        + " Log Groups are subscribed to Destination Type "
        + process.env.DESTINATION_ARN);
        console.log("Last invokeCount " + additionalArgs.invokeCount);
        errorHandler(null, "Success");
      }
    } catch (err) {
      errorHandler(err, "Error in fetching logGroups");
    }
  }

async function invoke_lambda(context, token, additionalArgs, errorHandler) {
  var payload = {"existingLogs": "true", "token": token, "additionalArgs": additionalArgs};
  try {
    await lambda.send(new InvokeCommand({
      InvocationType: 'Event',
      FunctionName: context.functionName,
      Payload: JSON.stringify(payload)
    }));
  } catch (err) {
      errorHandler(err, "Error invoking Lambda");
  }
}

async function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function processEvents(env, event, additionalArgs, errorHandler, retryCounter=0) {
  var logGroupName = event.detail.requestParameters.logGroupName;
  var logGroupRegex = validateRegex(env.LOG_GROUP_PATTERN);
  console.log("logGroupRegex: ", logGroupRegex);
  if (filterNewLogGroups(event, logGroupRegex)) {
    console.log("Subscribing: ", logGroupName, env.DESTINATION_ARN);
    try {
        await createSubscriptionFilter(logGroupName, env.DESTINATION_ARN, env.ROLE_ARN, additionalArgs);
    } catch (err) {
      errorHandler(err, "Error in Subscribing.");
      if (err && err.message === "Rate exceeded" && retryCounter <= maxRetryCounter) {
        retryCounter += 1
        const delayTime = Math.pow(2, retryCounter) * 1000; // Exponential backoff
        console.log(`ThrottlingException encountered. Retrying in ${delayTime}ms...Attempt ${retryCounter}/${maxRetryCounter}`);
        await delay(delayTime);
        await processEvents(env, event, additionalArgs, errorHandler, retryCounter);
      }
    };
  } else {
      console.log("Unmatched: ", logGroupName, env.DESTINATION_ARN);
  }
}

exports.handler = async function (event, context, callback) {
  let additionalArgs = {
    recordCount: 0,
    subscribeCount: 0,
    invokeCount: 0
  };
  if (event.additionalArgs) {
     additionalArgs = event.additionalArgs
  }
  console.log("Invoking Log Group connector function");
  function errorHandler(err, msg) {
    if (err) {
      console.log(err, msg);
        callback(err);
      } else {
        callback(null, "Success");
      }
    }
    if (!process.env.LOG_GROUP_PATTERN || process.env.LOG_GROUP_PATTERN.trim().length === 0) {
        console.warn("LOG_GROUP_PATTERN is empty, it will subscribe to all loggroups");
    }
    if (event.existingLogs == "true") {
      await processExistingLogGroups(context, event.token, additionalArgs, errorHandler);
    } else {
      await processEvents(process.env, event, additionalArgs, errorHandler);
    }
};